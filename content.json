{"meta":{"title":"blog of home","subtitle":"","description":"my blog of life","author":"Chanson Shi","url":"https://blog.shichanson.site","root":"/"},"pages":[{"title":"关于","date":"2021-04-11T08:48:54.506Z","updated":"2021-04-11T08:48:54.506Z","comments":false,"path":"about/index.html","permalink":"https://blog.shichanson.site/about/index.html","excerpt":"","text":"博主是一名从事IT行业四年的运维开发工程师，先后供职于DaoCloud、CaiCloud等公司,现就职于数字金融公司。 负责基础服务平台研发运维工作。 主要技术方向：OpenStack、Docker、Swarm、Kubernetes，ServiceMesh等方向。 擅长开发语言：Python、Golang。 热爱DevOps，熟悉开源人工智能训练平台kubeflow以及对于多框架训练支持的方案。"},{"title":"分类","date":"2021-04-11T07:34:59.742Z","updated":"2021-04-11T07:34:59.742Z","comments":false,"path":"categories/index.html","permalink":"https://blog.shichanson.site/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-04-11T07:34:59.742Z","updated":"2021-04-11T07:34:59.742Z","comments":true,"path":"links/index.html","permalink":"https://blog.shichanson.site/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-04-11T07:34:59.742Z","updated":"2021-04-11T07:34:59.742Z","comments":false,"path":"repository/index.html","permalink":"https://blog.shichanson.site/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-04-11T07:34:59.742Z","updated":"2021-04-11T07:34:59.742Z","comments":false,"path":"tags/index.html","permalink":"https://blog.shichanson.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"如何快速初始化 MacOS 开发环境","slug":"macos-init-env","date":"2020-09-20T12:25:23.000Z","updated":"2020-09-20T12:25:23.000Z","comments":true,"path":"2020/09/20/macos-init-env/","link":"","permalink":"https://blog.shichanson.site/2020/09/20/macos-init-env/","excerpt":"很多开发者比较喜欢用MacBook作为生产力工具，对于新电脑可以快速配置下开发环境。","text":"很多开发者比较喜欢用MacBook作为生产力工具，对于新电脑可以快速配置下开发环境。 MacOS 开发者初始化工具 打开以及关闭隐藏目录 1shift + command + . 安装开发工具 1xcode-select --install brew 工具使用 安装brew工具 1/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot; brew 基本命令 123456789brew -h #查找命令brew search #搜索软件brew install #安装软件brew uninstall #卸载软件brew update #更新所有软件brew upgrade #更新具体软件brew list #显示安装软件brew info / home# 查看软件信息：（home是打开软件的官网）brew outdated #查看哪些软件需要更新 oh my zsh 安装以及配置插件 安装oh my zsh 1$ sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 安装autojump插件 1brew install autojump 安装zsh-autosuggestion插件 1git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions 安装zsh-syntax-highlighting插件 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 配置以及激活插件 12vim ~/.zshrc # 添加选项plugins=(git autojump zsh-autosuggestions zsh-syntax-highlighting) # 重启控制台 oh my zsh 配置 powerlevel10k 主题 安装 powerlevel10k 123git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k# 配置方式 Set ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot; in ~/.zshrc. 配置powerlevel10k 1p10k configure # 通过交互配置主题 MacOS Hight Sierra清除DNS缓存 1sudo dscacheutil -flushcache;sudo killall -HUP mDNSResponder; 安装常用软件 123456789brew cask install v2rayubrew cask install shadowsocksx-ngbrew install redisbrew install helmbrew install kubernetes-clibrew install mysqlbrew cask install visual-studio-codebrew cask install typorabrew cask install iterm2","categories":[{"name":"Tools","slug":"Tools","permalink":"https://blog.shichanson.site/categories/Tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://blog.shichanson.site/tags/tools/"}],"author":"Mayer Shi"},{"title":"VMware Workstation Pro 16 内置容器工具vctl彻底替换docker（内含批量激活密钥）","slug":"vmwareworkstation_16_pro_license","date":"2020-09-16T12:25:23.000Z","updated":"2020-09-16T12:25:23.000Z","comments":true,"path":"2020/09/16/vmwareworkstation_16_pro_license/","link":"","permalink":"https://blog.shichanson.site/2020/09/16/vmwareworkstation_16_pro_license/","excerpt":"本篇文章为您介绍VMware本月刚发布的新版本PC桌面虚拟化软件VMware Workstation 16 Pro的容器新特性。","text":"本篇文章为您介绍VMware本月刚发布的新版本PC桌面虚拟化软件VMware Workstation 16 Pro的容器新特性。 新特性有哪些？ 支持容器和kubernetes 通过vctl命令行工具build、run、pull、push 管理容器镜像 支持通过KIND工具部署的kubernetes集群运行在workstation上。 注意： 要求Windows10 1809版本或者更高 虚拟机支持新的操作系统版本 RHEL 8.2 Debian 10.5 Fedora 32 CentOS 8.2 SLE 15 SP2 GA FreeBSD 11.4 ESXi 7.0 等等新特性。 VMware 新出的容器工具 vctl 使用说明 123456789101112131415161718192021222324252627282930313233343536373839vctl - A CLI tool for the container engine powered by VMware Workstationvctl Highlights:• Build and run OCI containers.• Push and pull container images between remote registries &amp; local storage.• Use a lightweight virtual machine (CRX VM) based on VMware Photon OS to host a container. Use &#x27;vctl system config -h&#x27; to learn more.• Easy shell access into virtual machine that hosts container. See &#x27;vctl execvm’.USAGE: vctl COMMAND [OPTIONS]COMMANDS: build Build a container image from a Dockerfile. create Create a new container from a container image. describe Show details of a container. exec Execute a command within a running container. execvm Execute a command within a running virtual machine that hosts container. help Help about any command. images List container images. inspect Return low-level information on objects. kind Get system environment ready for vctl-based KIND. login Log in to a registry. logout Log out from a registry. ps List containers. pull Pull a container image from a registry. push Push a container image to a registry. rm Remove one or more containers. rmi Remove one or more container images. run Run a new container from a container image. start Start an existing container. stop Stop a container. system Manage the container engine. tag Tag container images. version Print the version of vctl. volume Manage volumes.Run &#x27;vctl COMMAND --help&#x27; for more information on a command.OPTIONS: -h, --help Help for vctl 小试牛刀 启动vctl命令行工具 1vctl system start 基本用法 12345678vctl.exe run -d -p 80:80 --name nginx --restart unless-stopped daocloud.io/nginx #创建容器vctl.exe ps # 查看运行中的容器。──── ───── ─────── ── ───── ────── ─────────────NAME IMAGE COMMAND IP PORTS STATUS CREATION TIME──── ───── ─────── ── ───── ────── ─────────────nginx daocloud.io/nginx:latest /docker-entrypoint.s... 192.168.197.10 80:80/tcp running 2020-09-17T22:28:44+08:00 容器与虚拟机网络融合 通过上面vctl ps 命令查看到容器的IP其实是属于VMware Workstation 安装时自动创建的虚拟网络VMnet8子网下。是不是发现了什么？ 对，就是容器和虚拟机之间的网络处于同一平面，虚拟机与容器在网络中地位同等。 总结 笔者认为稳态和敏态两种类型应用将在未来企业架构中长期并存的，所以VMware这种将容器和虚拟化高度融合的方案是非常巧妙的，容器满足互联网化敏态应用的高速迭代场景，虚拟化兼顾需要稳态的数据库等中间件以及容器化成本过高的老旧系统场景。 VMware Workstation Pro 16 许可证密钥，批量永久激活 123ZF3R0-FHED2-M80TY-8QYGC-NPKYFYF390-0HF8P-M81RQ-2DXQE-M2UT6ZF71R-DMX85-08DQY-8YMNC-PPHV8 下载地址： https://n802.com/file/21152422-461565567","categories":[{"name":"Ops","slug":"Ops","permalink":"https://blog.shichanson.site/categories/Ops/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://blog.shichanson.site/tags/tools/"}],"author":"Mayer Shi"},{"title":"基于阿里云OSS解决前端图片跨域的问题","slug":"oss-crossdomain-ssl","date":"2020-08-09T03:25:23.000Z","updated":"2020-08-09T03:25:23.000Z","comments":true,"path":"2020/08/09/oss-crossdomain-ssl/","link":"","permalink":"https://blog.shichanson.site/2020/08/09/oss-crossdomain-ssl/","excerpt":"开发前端应用通常将图片等一些资源存放在一些对象存储中比如，阿里云OSS、腾讯OSS等，在oss的基础加上CDN进行资源分发。这种场景下前端开发一般都会遇到跨域问题，该篇博客记录下解决过程。","text":"开发前端应用通常将图片等一些资源存放在一些对象存储中比如，阿里云OSS、腾讯OSS等，在oss的基础加上CDN进行资源分发。这种场景下前端开发一般都会遇到跨域问题，该篇博客记录下解决过程。 登录阿里云oss账号，创建bucket。 对bucket进行跨域设置，设置规则如下： [] 针对OSS设置CDN，然后在dns中添加CNAME记录。 设置完毕以后，我们在开发中总是遇到报错。 1Mixed Content: The page at &#x27;https://www.mayershi.me/#/front/user/center&#x27; was loaded over HTTPS, but requested an insecure XMLHttpRequest endpoint &#x27;http://as.test.com/file/20200802115932-deqw.png&#x27;. This request has been blocked; the content must be served over HTTPS. 同时浏览器还报“与此网站构建的连接不完全安全。” 解决方案就是，将CDN所有的http请求强制转化成https.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://blog.shichanson.site/categories/frontend/"}],"tags":[{"name":"前端跨域","slug":"前端跨域","permalink":"https://blog.shichanson.site/tags/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F/"}],"author":"Mayer Shi"},{"title":"搭建免费科学上网服务器v2ray","slug":"gcp-install-gfw-v2ray-server","date":"2020-08-06T12:25:23.000Z","updated":"2020-08-06T12:25:23.000Z","comments":true,"path":"2020/08/06/gcp-install-gfw-v2ray-server/","link":"","permalink":"https://blog.shichanson.site/2020/08/06/gcp-install-gfw-v2ray-server/","excerpt":"利用gcp每个绑定信用卡会送300美元可以免费搭建一个v2ray的梯子，而且这个羊毛可以重复薅无数次。当该账号用完以后，重新注册一个新的谷歌账号，绑定原来的信用卡继续赠送300美元。","text":"利用gcp每个绑定信用卡会送300美元可以免费搭建一个v2ray的梯子，而且这个羊毛可以重复薅无数次。当该账号用完以后，重新注册一个新的谷歌账号，绑定原来的信用卡继续赠送300美元。 安装步骤 利用gcp每个绑定信用卡会送300美元可以免费搭建一个梯子，而且这个羊毛可以重复薅无数次。当该账号用完以后，重新注册一个新的谷歌账号，绑定原来的信用卡继续赠送300美元。 Google Cloud Platform： https://cloud.google.com/gcp 创建compute engine—虚拟机实例—创建实例—服务器选址（ 除非有特殊需求，区域一般选亚太-，香港、台湾速度比较快，但不是太稳定，我一般选日本。） 然后开始搭建梯子，软件比较多，SS，SSR，Trojan；但是现在主流还是V2Ray，用233boy大的一键脚本安装会比较简单，只有2行命令 1sudo -i bash &lt;(curl -s -L https://git.io/v2ray.sh) 然后如果想选择WebSocket + TLS传输协议，还需要有一个域名。","categories":[{"name":"Ops","slug":"Ops","permalink":"https://blog.shichanson.site/categories/Ops/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://blog.shichanson.site/tags/tools/"}],"author":"Mayer Shi"},{"title":"基于Ubuntu安装ROS 系统（melodic版本）","slug":"install-ros-melodic-ubuntu-18-04","date":"2020-06-04T02:25:23.000Z","updated":"2020-06-04T02:25:23.000Z","comments":true,"path":"2020/06/04/install-ros-melodic-ubuntu-18-04/","link":"","permalink":"https://blog.shichanson.site/2020/06/04/install-ros-melodic-ubuntu-18-04/","excerpt":"ROS (Robot Operating System, 机器人操作系统) 提供一系列程序库和工具以帮助软件开发者创建机器人应用软件。它提供了硬件抽象、设备驱动、函数库、可视化工具、消息传递和软件包管理等诸多功能。","text":"ROS (Robot Operating System, 机器人操作系统) 提供一系列程序库和工具以帮助软件开发者创建机器人应用软件。它提供了硬件抽象、设备驱动、函数库、可视化工具、消息传递和软件包管理等诸多功能。 安装版本要求： Ubuntu系统版本18.04 版本 ROS 版本为Melodic版本 安装步骤 配置Ubuntu的repository源,编辑/etc/apt/sources.list文件。 12345678910111213# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 更新源以及更新系统 12sudo apt-get update -ysudo apt-get upgrade -y 配置ROS的Ubuntu源, 12345678910ROS 镜像使用帮助新建 /etc/apt/sources.list.d/ros-latest.list，内容为：你的Debian/Ubuntu版本: Ubuntu 18.04 LTSdeb https://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ bionic main然后再输入如下命令，信任ROS的GPG Key，并更新索引：sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654sudo apt update 开始安装ROS系统 1sudo apt install ros-melodic-desktop-full -y ROS环境变量设置 12echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 安装构建包依赖 1sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential 初始化rosdep工具，在使用许多ROS工具之前，您需要初始化rosdep。rosdep使您能够轻松地为要编译的源安装系统依赖性，并且是运行ROS中某些核心组件所必需的。 123sudo apt install python-rosdepsudo rosdep initrosdep update 验证当前安装环境是否正确。 1234567891011121314151617181920212223242526272829303132333435# 开启一个终端执行如下命令ros@ubuntu:~$ roscore... logging to /home/mayershi/.ros/log/51594486-a3d7-11ea-a495-001c425709d4/roslaunch-ubuntu-14528.logChecking log directory for disk usage. This may take a while.Press Ctrl-C to interruptDone checking log file disk usage. Usage is &lt;1GB.started roslaunch server http://ubuntu:41953/ros_comm version 1.14.5SUMMARY========PARAMETERS * /rosdistro: melodic * /rosversion: 1.14.5NODESauto-starting new masterprocess[master]: started with pid [14541]ROS_MASTER_URI=http://ubuntu:11311/setting /run_id to 51594486-a3d7-11ea-a495-001c425709d4process[rosout-1]: started with pid [14552]started core service [/rosout]# 新开一个终端执行命令ros@ubuntu:~$ rosrun turtlesim turtlesim_node# 会生产成一个小乌龟节点# 新开另外一个终端执行命令ros@ubuntu:~$ rosrun turtlesim turtle_teleop_key# 在此终端上通过方向键来操控小乌龟移动。 效果如图：","categories":[{"name":"ROS","slug":"ROS","permalink":"https://blog.shichanson.site/categories/ROS/"}],"tags":[{"name":"机器人","slug":"机器人","permalink":"https://blog.shichanson.site/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"}],"author":"Mayer Shi"},{"title":"zoom 国际版视频会议软件屏蔽后解决办法","slug":"zoom-not-connect","date":"2019-12-26T03:11:46.000Z","updated":"2019-12-26T03:11:46.000Z","comments":true,"path":"2019/12/26/zoom-not-connect/","link":"","permalink":"https://blog.shichanson.site/2019/12/26/zoom-not-connect/","excerpt":"前段时间zoom视频会议软件由于视频数据没法留存在中国，导致zoom被墙掉了。但是可以通过一种方式解决。","text":"前段时间zoom视频会议软件由于视频数据没法留存在中国，导致zoom被墙掉了。但是可以通过一种方式解决。 修改本地hosts文件 123456789101112131415161718192021222324252627282930313233343536373839sudo vim /etc/hosts221.122.88.132 zoom.us52.202.62.203 zoom.us52.202.62.241 zoom.us52.202.62.241 share.zoom.us52.202.62.203 share.zoom.us104.16.51.111 support.zoom.us104.16.52.111 support.zoom.us104.16.53.111 support.zoom.us104.16.54.111 support.zoom.us221.122.88.132 www.zoom.us221.122.88.132 www3.zoom.us221.122.88.132 google.zoom.us221.122.88.132 facebook.zoom.us221.122.88.132 log.zoom.us221.122.88.132 api.zoom.us221.122.88.132 launcher.zoom.us221.122.88.132 imauth.zoom.us221.122.88.132 static.zoom.us221.122.89.232 file-ia.zoom.us221.122.89.180 xmpp001.zoom.us221.122.89.180 xmpp002.zoom.us221.122.89.180 xmpp003.zoom.us221.122.89.180 xmpp004.zoom.us221.122.89.180 xmpp005.zoom.us221.122.89.180 xmpp006.zoom.us221.122.89.180 xmpp007.zoom.us221.122.89.180 xmpp008.zoom.us221.122.89.180 xmpp009.zoom.us221.122.89.180 xmpp010.zoom.us221.122.89.180 xmpp011.zoom.us221.122.89.180 xmpp012.zoom.us221.122.89.180 xmpp013.zoom.us221.122.89.180 xmpp014.zoom.us221.122.89.180 xmpp015.zoom.us221.122.89.231 xmppapi.zoom.us 验证是否可以访问 浏览器输入： https://zoom.us","categories":[{"name":"Tools","slug":"Tools","permalink":"https://blog.shichanson.site/categories/Tools/"}],"tags":[{"name":"zoom","slug":"zoom","permalink":"https://blog.shichanson.site/tags/zoom/"}],"author":"Mayer Shi"},{"title":"GitOps 云原生持续交付方式","slug":"gitops-basic-concept","date":"2019-12-24T10:35:58.000Z","updated":"2019-12-24T10:35:58.000Z","comments":true,"path":"2019/12/24/gitops-basic-concept/","link":"","permalink":"https://blog.shichanson.site/2019/12/24/gitops-basic-concept/","excerpt":"大家比较熟知DevOps、AiOps概念，也听说过GitOps。但是GitOps究竟是个什么东西，可能不是太了解。所以本篇文章主要介绍GitOps的一些基础知识以及核心思想。","text":"大家比较熟知DevOps、AiOps概念，也听说过GitOps。但是GitOps究竟是个什么东西，可能不是太了解。所以本篇文章主要介绍GitOps的一些基础知识以及核心思想。 什么是GitOps ？ GitOps是一种进行Kubernetes集群管理和应用交付的方式。它通过将Git用作声明性基础结构和应用程序的单一事实来源来工作。将Git作为交付流水线的核心，每个开发人员都可以提交拉取请求（Pull Request）并使用Gi​​t来加速和简化Kubernetes的应用程序部署和运维任务。通过使用像Git这样的简单工具，开发人员可以更高效地将注意力集中在业务开发而不是运维相关任务上。 GitOps的主要优势 当使用Git提交基础架构代码更改时，自动化的交付流水线会将这些更改应用到应用程序的实际基础架构上。但是GitOps的想法远不止于此——它还会使用工具将整个应用程序的实际生产状态与基础架构源代码进行比较，然后它会告诉集群哪些基础架构源代码与实际环境不匹配。 通过应用GitOps最佳实践，应用系统的基础架构和应用程序代码都有“真实来源”——其实是将基础架构和应用程序代码都存放在gitlab、或者github等版本控制系统上。这使开发团队可以提高开发和部署速度并提高应用系统可靠性。 将GitOps理论方法应用在持续交付流水线上，有诸多优势和特点： 安全的云原生CI/CD pipeline 模型 更快的平均部署时间和平均恢复时间 稳定且可重现的回滚（例如，根据Git恢复/回滚/ fork） 与监控和可视化工具相结合，对已经部署的应用进行全方位的监控 运用GitOps的基本前提 没有单一工具可以完成流水线中所需的所有工作，因此可以为流水线的不同部分选择最佳工具。但是多工具部件组合使用，使得所有部件粘合在一起变成了创建流水线最难的一部分。不管如何选择构造自己的交付流水线，将基于Git（或者其他版本控制工具）的GitOps最佳实践应用在交付流水线中都是一个不二选择，这将使构建持续交付流水线，以及后续的推广变得更加容易，这不仅从技术角度而且从文化角度来看都是如此。同时gitOps也不是银弹，发挥它的最大作用需要一些基本前提。 不可变基础设施 在容器尚未普及的时代，很多公司运维采用各种自动化框架做自己的运维平台来使得相同应用能在测试生产等环境安全稳定运行，但是长期运行后依旧会出现同一集群中的机器的环境不一致的问题，进而引发各种故障和问题的发生。容器技术通过将应用环境与应用打包成镜像使其变成一种不可变单元，进而实现了不可变基础设施。如何高效的使用不可变基础设施资源呢，这时候k8s的诞生解决了该问题。 声明性容器编排 Kubermetes作为一个云原生的工具，可以把它的“声明性”看作是“代码”，声明意味着配置由一组事实而不是一组指令组成，例如，“有十个redis服务器”，而不是“启动十个redis服务器，告诉我它是否有效”。借助Kubermetes的声明性特点，应用系统的整个配置文件集可以在Git库中进行版本控制。通过使用Git库，应用程序更容易部署到Kubernetes中，以及进行版本回滚。更重要的是，当灾难发生时，群集的基础架构可以从Git库中可靠且快速地恢复。 GitOps的基本原则 以下是在云原生环境中GitOps的原则： 任何能够被描述的内容都必须存储在Git库中 通过使用Git作为存储声明性基础架构和应用程序代码的存储仓库，可以方便地监控集群，以及检查比较实际环境的状态与代码库上的状态是否一致。所以，我们的目标是描述系统相关的所有内容：策略，代码，配置，甚至监控事件和版本控制等，并且将这些内容全部存储在版本库中，在通过版本库中的内容构建系统的基础架构或者应用程序的时候，如果没有成功，则可以迅速的回滚，并且重新来过。 不应直接使用Kubectl 作为一般规则，不提倡在命令行中直接使用kubectl命令操作执行部署基础架构或应用程序到集群中。还有一些开发者使用CI工具驱动应用程序的部署，但如果这样做，可能会给生产环境带来潜在不可预测的风险。 调用Kubernetes 的API的接口或者控制器应该遵循 Operator 模式 调用Kubernetes 的API的接口或者控制器应该遵循 Operator 模式（什么是Operator 模式？），集群的状态和Git库中的配置文件等要保持一致，并且查看分析它们之间的状态差异。","categories":[{"name":"GitOps","slug":"GitOps","permalink":"https://blog.shichanson.site/categories/GitOps/"}],"tags":[{"name":"gitops","slug":"gitops","permalink":"https://blog.shichanson.site/tags/gitops/"}],"author":"Mayer Shi"},{"title":"gitlab-ee 企业版自签许可证license","slug":"crack-gitlab-ee-licence","date":"2019-12-23T03:27:40.000Z","updated":"2019-12-23T03:27:40.000Z","comments":true,"path":"2019/12/23/crack-gitlab-ee-licence/","link":"","permalink":"https://blog.shichanson.site/2019/12/23/crack-gitlab-ee-licence/","excerpt":"本篇文章主要是研究gitlab-ee的licence签发方式，仅供大家学习参考使用。请尊重软件开发者成果，支持正版。","text":"本篇文章主要是研究gitlab-ee的licence签发方式，仅供大家学习参考使用。请尊重软件开发者成果，支持正版。 背景 最近帮一个朋友推动开发测试一体化从DevOps转向GitOps。对于什么是GitOps，有时间搞个专题博客来讲讲这个概念以及最佳实践。总之在推进GitOps的时候需要，需要一些gitlab-ee 的高级特性。 1. 安装ruby环境以及gem包管理工具 由于我的电脑是mbp,所以自带ruby开发环境,无需安装。 安装相关ruby包依赖gitlab、gitlab-license、openssl 123sudo gem install gitlabsudo gem install gitlab-licensesudo gem install openssl 2. 编写创建license的ruby脚本，并生成license文件 创建脚本文件 1vim createlicense.rb 文件内容如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141require &#x27;openssl&#x27;require &#x27;gitlab/license&#x27;# Generate a key pair. You should do this only once.key_pair = OpenSSL::PKey::RSA.generate(2048)# Write it to a file to use in the license generation application.File.open(&quot;license_key&quot;, &quot;w&quot;) &#123; |f| f.write(key_pair.to_pem) &#125;# Extract the public key.public_key = key_pair.public_key# Write it to a file to ship along with the main application.File.open(&quot;license_key.pub&quot;, &quot;w&quot;) &#123; |f| f.write(public_key.to_pem) &#125;# In the license generation application, load the private key from a file.private_key = OpenSSL::PKey::RSA.new File.read(&quot;license_key&quot;)Gitlab::License.encryption_key = private_key# Build a new license.license = Gitlab::License.new# License information to be rendered as a table in the admin panel.# E.g.: &quot;This instance of GitLab Enterprise Edition is licensed to:&quot;# Specific keys don&#x27;t matter, but there needs to be at least one.license.licensee = &#123; &quot;Name&quot; =&gt; &quot;tester&quot;, &quot;Company&quot; =&gt; &quot;Google Inc&quot;, &quot;Email&quot; =&gt; &quot;test@163.com&quot;&#125;# The date the license starts. # Required.license.starts_at = Date.new(2019, 4, 24) # license 开始生效时间# The date the license expires. # Not required, to allow lifetime licenses.license.expires_at = Date.new(2026, 4, 23) # license 到期时间# The below dates are hardcoded in the license so that you can play with the# period after which there are &quot;repercussions&quot; to license expiration.# The date admins will be notified about the license&#x27;s pending expiration. # Not required.license.notify_admins_at = Date.new(2026, 3, 23) # license 管理员过期提醒时间# The date regular users will be notified about the license&#x27;s pending expiration.# Not required.license.notify_users_at = Date.new(2026, 3, 23) # license 普通用户过期提醒时间# The date &quot;changes&quot; like code pushes, issue or merge request creation # or modification and project creation will be blocked.# Not required.license.block_changes_at = Date.new(2026, 5, 7) # Restrictions bundled with this license.# Not required, to allow unlimited-user licenses for things like educational organizations.license.restrictions = &#123; # The maximum allowed number of active users. # Not required. active_user_count: 10000 # license 人数配额 # We don&#x27;t currently have any other restrictions, but we might in the future.&#125;puts &quot;License:&quot;puts license# Export the license, which encrypts and encodes it.data = license.exportputs &quot;Exported license:&quot;puts data# Write the license to a file to send to a customer.File.open(&quot;GitLabBV.gitlab-license&quot;, &quot;w&quot;) &#123; |f| f.write(data) &#125;# In the customer&#x27;s application, load the public key from a file.public_key = OpenSSL::PKey::RSA.new File.read(&quot;license_key.pub&quot;)Gitlab::License.encryption_key = public_key# Read the license from a file.data = File.read(&quot;GitLabBV.gitlab-license&quot;) # 生成license存储文件名# Import the license, which decodes and decrypts it.$license = Gitlab::License.import(data)puts &quot;Imported license:&quot;puts $license# Quit if the license is invalidunless $license raise &quot;The license is invalid.&quot;end# Quit if the active user count exceeds the allowed amount:if $license.restricted?(:active_user_count) active_user_count = 1000 if active_user_count &gt; $license.restrictions[:active_user_count] raise &quot;The active user count exceeds the allowed amount!&quot; endend# Show admins a message if the license is about to expire.if $license.notify_admins? puts &quot;The license is due to expire on #&#123;$license.expires_at&#125;.&quot;end# Show users a message if the license is about to expire.if $license.notify_users? puts &quot;The license is due to expire on #&#123;$license.expires_at&#125;.&quot;end# Block pushes when the license expired two weeks ago.module Gitlab class GitAccess # ... def check(cmd, changes = nil) if $license.block_changes? return build_status_object(false, &quot;License expired&quot;) end # Do other Git access verification # ... end # ... endend# Show information about the license in the admin panel.puts &quot;This instance of GitLab Enterprise Edition is licensed to:&quot;$license.licensee.each do |key, value| puts &quot;#&#123;key&#125;: #&#123;value&#125;&quot;endif $license.expired? puts &quot;The license expired on #&#123;$license.expires_at&#125;&quot;elsif $license.will_expire? puts &quot;The license will expire on #&#123;$license.expires_at&#125;&quot;else puts &quot;The license will never expire.&quot;end 执行以上license脚本文件，生成三个文件, 12345678910111213141516171819202122232425262728293031323334ruby createlicense.rb # 执行脚本生成如下内容License:#&lt;Gitlab::License:0x00007fd08691eca0&gt;Exported license:eyJkYXRhIjoiWVo0VEIraWJQai8zUDhWRi9OK2Y3d2JXcG1ucVZGbXhUamtPS0QyY01BSG9XYlBLRlh0QUcvQ1UzMm9EXG5tU1RSd0pqUmlRT2hOOC9KOWJiYk9mZ0krUmt5aWd2WnBNdGYydVZsUTFEemhFSU1jZWk5VjdtTWJycS9cbk9IV3BmMjR3TFFmcXhQdHVvNVFDbVd0Z2Njc2lNUXhPUzVxUTN0YkRvRDRhYTk2OVQvbjN4clc1RkNHZlxuUXU0TnZ1OHhqcjlZMTJIZk5yaVd3a2ZLZTBqZitUcExvem9GTk9QY2d5R3hGdEtkNGVUVzdpa0tQRUNCXG5IRmZYVlVydHdBU3Fmei96WFNvaHRGVTFLWW1USkxMOFQ5eW5PTFdpQ1gycXRIYkF1T0hLV0N0bi9WdE5cbjViZ3VRd05xd2hSOHlNanB6SFhNNC9OemZMVkRVQ3ZTTndVZWR6Q2Q1Q3hrcE9BOEU1cFN5aXRiSTBkZ1xucTJ1ekJnSHNtdlVVdE5mbjFPUWtTc0FSdkE2QUxUdGs1ZXZZN3Z6SDJ5N3FMZz09XG4iLCJrZXkiOiJnZ200N1hvRnkrOTRYb09wcFh5akE1VVo0NTU5REhxeWhVVHMzVWV1dDhRRDRzZGpReVZwRGVpQkFuajZcblgvL2RvYnM5QVRyYlRZa0V0SEJadUN5bGR5dUhlbEhQSHdJNUxSRXgyeUpkb2NBRnRVVTNlTjdKcm9ZZ1xuVGJPaXk5c1E4eldNMWhZYWlWWDAyeDdpTGx6eHA3eDJVSWJpRkZZd2J1dmZXeGtiMk10dnVQdFdsOUt0XG5mcW91b0dYN0ZZclV1d3NWOGVNNTcyeS90elpMNFBLMFZvTE5vN3d6eEdveW1FbUNPSm9kYXVNR0IydjNcbkVybnFac2xsdlo1ZThnNDFKMElLclhLZ1lEK2J3WUR1a1hqcHk4OU5GZHVaaGgzK3V5ZFNROWJwSC9wYVxuZjA4YUUwUzBkSzhyeTU2SzVnbEVweFRtc09SZlBTUmhSSVhnalZsYVB3PT1cbiIsIml2IjoiN1VLSTh0UXo0aFZ6bGV5QW9kSWFxQT09XG4ifQ==Imported license:#&lt;Gitlab::License:0x00007fd086926f40&gt;This instance of GitLab Enterprise Edition is licensed to:Name: testCompany: Google IncEmail: test@163.comThe license will expire on 2026-04-23ls . # 查看当前目录下文件GitLabBV.gitlab-license createlicense.rb license_key license_key.pub 3. 替换公钥以及激活license 将createlicense.rb脚本文件生成的license_key.pub公钥内容替换到gitlab的/opt/gitlab/embedded/service/gitlab-rails/.license_encryption_key.pub中。然后重启gitlab，gitlab-ctl restart. 重启完毕后，将脚本生成的GitLabBV.gitlab-license文件，导入gitlab激活页面即可激活了。 4. 修改gitlab-ee的等级为ULTIMATE_PLAN 修改gitlab的文件 vim /opt/gitlab/embedded/service/gitlab-rails/ee/app/models/license.rb 123def plan restricted_attr(:plan).presence || STARTER_PLAN ## 将STARTER_PLAN 修改为 ULTIMATE_PLANend 小问题 就是生成的license虽然可以激活，但是license页面老是报500错误。这个得看下后台日志排查下即可。","categories":[{"name":"DevOps","slug":"DevOps","permalink":"https://blog.shichanson.site/categories/DevOps/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"https://blog.shichanson.site/tags/gitlab/"}],"author":"Mayer Shi"},{"title":"本地搭建kubernetes环境","slug":"k8s-local-install","date":"2019-12-20T03:27:45.000Z","updated":"2019-12-20T03:27:45.000Z","comments":true,"path":"2019/12/20/k8s-local-install/","link":"","permalink":"https://blog.shichanson.site/2019/12/20/k8s-local-install/","excerpt":"此篇文章主要是介绍如何通过minikube快速部署一个k8s环境用作学习和实验。我演示的机器是macOS，k8s版本是1.15.x 最新版本。无需翻墙哦。","text":"此篇文章主要是介绍如何通过minikube快速部署一个k8s环境用作学习和实验。我演示的机器是macOS，k8s版本是1.15.x 最新版本。无需翻墙哦。 条件准备 安装虚拟化软件virtualbox驱动 1brew cask install virtualbox 安装kubectl 客户端 1brew install kubernetes-cli 下载阿里云minikube 1curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v1.2.0/minikube-darwin-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/ 开始搭建 启动minikube安装k8s 1.15.0 版本 1minikube start --registry-mirror=https://registry.docker-cn.com --kubernetes-version v1.15.0 成果验证 123456789101112131415161718# 查看节点$ kubectl get nodeNAME STATUS ROLES AGE VERSIONminikube Ready master 10m v1.15.0# 查看kube-system ns 下的pod状态$ kubectl get pod -n kube-systemNAME READY STATUS RESTARTS AGEcoredns-6967fb4995-9bplg 1/1 Running 0 10mcoredns-6967fb4995-9xn9t 1/1 Running 0 10metcd-minikube 1/1 Running 0 9m25skube-addon-manager-minikube 1/1 Running 0 9m8skube-apiserver-minikube 1/1 Running 0 9m24skube-controller-manager-minikube 1/1 Running 0 9m21skube-proxy-2gw65 1/1 Running 0 10mkube-scheduler-minikube 1/1 Running 0 9m39sstorage-provisioner 1/1 Running 0 10m 开启dashboard 1234$ minikube addons enable dashboard✅ dashboard was successfully enabled$ minikube dashboard","categories":[{"name":"Container Cloud","slug":"Container-Cloud","permalink":"https://blog.shichanson.site/categories/Container-Cloud/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://blog.shichanson.site/tags/kubernetes/"}],"author":"Mayer Shi"},{"title":"docker swarm 部署 gitlab-ee 并设置https","slug":"gitlab-install-docker","date":"2019-12-19T03:58:10.000Z","updated":"2019-12-19T03:58:10.000Z","comments":true,"path":"2019/12/19/gitlab-install-docker/","link":"","permalink":"https://blog.shichanson.site/2019/12/19/gitlab-install-docker/","excerpt":"通过docker swarm 安装部署gitlab服务可以更方便的升级版本，以及高效运维。本篇主要介绍gitlab的docker swarm 安装方式。","text":"通过docker swarm 安装部署gitlab服务可以更方便的升级版本，以及高效运维。本篇主要介绍gitlab的docker swarm 安装方式。 初始化docker swarm 集群 1$ sudo docker swarm init 创建lvm逻辑磁盘卷，格式化并挂载/gitlab目录下 12345$ sudo fdisk /dev/vdb$ sudo pvcreate /dev/vdb1$ sudo vgcreate gitlab /dev/vdb1$ sudo lvcreate -L 199G -n gitlab gitlab$ sudo mkfs.xfs /dev/gitlab/gitlab 创建gitlab数据挂载目录 1$ sudo mkdir -pv /gitlab/&#123;config,data,logs&#125; 开始部署gitlab-ee版本 123456789101112 $ sudo docker service create \\ --name &quot;git-inside-gitlab&quot; \\ --hostname git.test.cn \\ --network pilipa-network \\ --replicas 1 \\ --publish &quot;mode=host,published=2222,target=22&quot; \\ --publish &quot;mode=host,published=80,target=80&quot; \\ --publish &quot;mode=host,published=443,target=443&quot; \\ --mount type=bind,src=/gitlab/config,dst=/etc/gitlab \\ --mount type=bind,src=/gitlab/logs,dst=/var/log/gitlab \\ --mount type=bind,src=/gitlab/data,dst=/var/opt/gitlab \\&quot;gitlab/gitlab-ee:11.4.9-ee.0&quot; 配置gitlab.rb 1234external_url &quot;https://git.test.cn&quot;nginx[&#x27;redirect_http_to_https&#x27;] =truenginx[&#x27;ssl_certificate&#x27;] = &quot;/etc/gitlab/ssl/git.test.cn.crt&quot;nginx[&#x27;ssl_certificate_key&#x27;] = &quot;/etc/gitlab/ssl/git.test.cn.key&quot; 重新加载配置文件使其生效 1$ sudo gitlab-ctl reconfigure 通过阿里云的SLB代理到ECS上搭建的gitlab服务上，然后设置dns解析即可。","categories":[{"name":"Ops","slug":"Ops","permalink":"https://blog.shichanson.site/categories/Ops/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"https://blog.shichanson.site/tags/gitlab/"}],"author":"Mayer Shi"},{"title":"命令行下如何获取外网地址","slug":"curl-ip","date":"2019-12-18T19:09:58.000Z","updated":"2019-12-18T19:09:58.000Z","comments":true,"path":"2019/12/19/curl-ip/","link":"","permalink":"https://blog.shichanson.site/2019/12/19/curl-ip/","excerpt":"公司业务涉及到数据安全层面的时候，往往会通过IP白名单的方式来控制数据或者应用的访问。如何快速获取当前主机所在外网IP是个刚需。","text":"公司业务涉及到数据安全层面的时候，往往会通过IP白名单的方式来控制数据或者应用的访问。如何快速获取当前主机所在外网IP是个刚需。 第一种方式： 12345678910curl cip.cccurl ipinfo.iocurl myip.ipip.netcurl http://members.3322.org/dyndns/getipcurl https://ip.cn # 推荐使用这个curl httpbin.org/ipcurl ip.sb curl whatismyip.akamai.comcurl ipecho.net/plaincurl icanhazip.com 第二种方式 123curl -s http://ip.taobao.com/service/getIpInfo2.php?ip=myip | awk -F&quot;ip&quot; &#x27;&#123;print $2&#125;&#x27; | awk -F&#x27;&quot;&#x27; &#x27;&#123;print $3&#125;&#x27;curl -s ifcfg.cn/echo | python -m json.tool","categories":[{"name":"Ops","slug":"Ops","permalink":"https://blog.shichanson.site/categories/Ops/"}],"tags":[{"name":"cmd","slug":"cmd","permalink":"https://blog.shichanson.site/tags/cmd/"}],"author":"Mayer Shi"},{"title":"下一代数据中心云操作系统 kubernetes","slug":"k8s-cloud-001","date":"2019-12-01T03:06:42.000Z","updated":"2019-12-01T03:06:42.000Z","comments":true,"path":"2019/12/01/k8s-cloud-001/","link":"","permalink":"https://blog.shichanson.site/2019/12/01/k8s-cloud-001/","excerpt":"云时代中的佼佼者k8s的系列高质量干货文章，其中包含基础概念、组件原理、基本使用、生态工具、以及生产中的最佳实践。","text":"云时代中的佼佼者k8s的系列高质量干货文章，其中包含基础概念、组件原理、基本使用、生态工具、以及生产中的最佳实践。 本篇前言 在开源领域长期霸持数据中心核心地位非Linux莫属，但是随着云计算的崛起以及开源世界大公司不断加入诞生了新一代数据中心云操作系统k8s，可以毫不夸张的说k8s是开源世界一款伟大产品。 kubernetes 是什么？ Kubernetes是一个可移植，可扩展的开源平台，用于管理容器化工作负载和服务，有助于声明性配置和自动化。它拥有庞大，快速发展的生态系统。Kubernetes服务，支持和工具广泛可用。 Kubernetes这个名字源于希腊语，意思是舵手或飞行员。谷歌在2014年开放了Kubernetes项目.Kubernetes建立在谷歌拥有大量运行生产工作量的十五年经验的基础上，结合了社区中的最佳创意和实践。 IT应用运维变迁 透过IT应用运维的变迁，让我们来看看为什么Kubernetes如此有用和伟大。 下一代数据中心云操作系统 kubernetes「容器云连载」 物理机部署时代： 早期，在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源浪费问题。例如，如果在物理服务器上运行多个应用程序，则可能存在一个应用程序占用大部分资源的情况，因此其他应用程序会受到影响。解决方案是在不同的物理服务器上运行不同应用程序。但是由于资源未得到充分利用，并且扩展性很差，企业维护许多物理服务器的成本很高。 虚拟化部署时代：为了解决资源利用率的问题，引入了虚拟化。它允许您在单个物理服务器的CPU上运行多个虚拟机（VM）。虚拟化允许应用程序在VM之间隔离，并提供一定程度的安全性，因为另一个应用程序无法随便访问另外一VM上运行应用程序的信息。 虚拟化可以更好地利用物理服务器中的资源，也可以实现更好的可扩展性，快速添加或更新应用程序，降低硬件成本等等优点。 每个VM都是在虚拟化硬件之上运行包含所有组件（包括其自己的操作系统）的完整操作系统。 容器部署时代：容器类似于VM，但它们属于轻量级虚拟化，隔离性相对宽松。多个应用程序容器之间共享宿主操作系统（OS）。与VM类似，容器具有自己的文件系统，CPU，内存，进程空间等。当它们与底层基础架构分离时，它们可以跨云和OS分发进行移植。 容器的优势 敏捷应用程序创建和部署：与VM映像使用相比，增加了容器镜像创建的简便性和效率。 持续开发，集成和部署：通过快速简便的回滚（由于镜像不变性）提供可靠且频繁的容器镜像构建和部署。 Dev和Ops关注点分离：在构建/发布时而不是部署时创建应用程序容器镜像，从而将应用程序与基础架构分离。 开发，测试和生产的环境一致性：在笔记本电脑上运行与在云中运行相同。 云和操作系统分发可移植性：在Ubuntu，RHEL，CoreOS，本地，阿里云，腾讯云和其他任何地方都可以运行。 以应用程序为中心的管理：提高在虚拟硬件上运行OS的抽象级别，以及使用逻辑资源在OS上运行应用程序。 资源隔离与利用：可预测的应用程序性能，高效率和高密度。 为什么需要kubernetes 以及用它能做什么？ 在生产环境中，您需要管理运行应用程序的容器并确保没有停机时间。例如，如果容器发生故障，则需要启动另一个容器，添加负载均衡等一系列动作。如果这些直接交给一个系统去处理，会不会更高效和便捷？ kubernetes 就是很好解决了包含以上所说各种问题的系统 ！Kubernetes为您提供了一个弹性运行分布式系统的框架。它可以管理应用的扩展，故障转移，负载均衡等。例如，Kubernetes可以轻松管理应用系统的canary发布。k8s 提供如下有用特性： 服务发现和负载平衡 Kubernetes可以使用内部DNS名称或使用自己的IP地址提供服务入口。如果容器的流量很高，Kubernetes能够负载均衡并分配网络流量，确保应用可以稳定提供服务。 存储编排 Kubernetes允许您自动安装您选择的存储系统，例如本地存储，公共云提供商等。 自动部署和回滚 您可以使用Kubernetes描述已部署容器的所需状态，并且可以控制速率将实际状态更改为所需状态。例如，您可以控制Kubernetes为您的deploy自动创建新容器，删除现有容器并将所有资源用于新容器。 自我修复与高可用 Kubernetes重新启动失败的容器，替换容器，杀死不响应用户定义的运行状况检查的容器，并且服务没有真正运行就绪前不会提前暴露给调用客户端。 密钥和配置管理 Kubernetes允许您存储和管理敏感信息，例如密码，OAuth令牌和ssh密钥。您可以部署和更新秘钥和应用程序配置，而无需重建容器镜像，也不会在应用程序中暴露秘钥。","categories":[{"name":"Container Cloud","slug":"Container-Cloud","permalink":"https://blog.shichanson.site/categories/Container-Cloud/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://blog.shichanson.site/tags/kubernetes/"}],"author":"Mayer Shi"},{"title":"jenkins 初始化无法拉取插件的解决办法","slug":"k8s-jenkins-ops","date":"2019-11-21T02:58:10.000Z","updated":"2019-11-21T02:58:10.000Z","comments":true,"path":"2019/11/21/k8s-jenkins-ops/","link":"","permalink":"https://blog.shichanson.site/2019/11/21/k8s-jenkins-ops/","excerpt":"jenkins被很多互联网用于devops工具，同时jenkins拥有庞大的插件生态使其拥有强大的功能，但是拉取插件的时候遇到了下载不了的问题，通过配置国内插件镜像中心来解决。","text":"jenkins被很多互联网用于devops工具，同时jenkins拥有庞大的插件生态使其拥有强大的功能，但是拉取插件的时候遇到了下载不了的问题，通过配置国内插件镜像中心来解决。 环境描述: 生产环境的jenkins 出现故障，删除jenkins应用的pod，使其重建，但是拉取的插件中心是updates.jenkins.io站点，这个站点突然无法访问。我们jenkins始终无法启动。jenkins的deploy会启动一个initcontainer来初始化配置以及拉取插件hpi文件。但是始终无法拉取成功。 看到github中个解决方案，在jenkins的init容器中加了一个环境变量就可以从jenkins的镜像节点拉取完毕。 环境变量是： 1JENKINS_UC_DOWNLOAD: https://mirrors.tuna.tsinghua.edu.cn/jenkins/ 同时改下配置文件： jenkins/hudson.model.UpdateCenter.xml 1234567&lt;?xml version=&#x27;1.1&#x27; encoding=&#x27;UTF-8&#x27;?&gt;&lt;sites&gt; &lt;site&gt; &lt;id&gt;default&lt;/id&gt; &lt;url&gt;https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/current/update-center.json&lt;/url&gt; &lt;/site&gt;&lt;/sites&gt;","categories":[{"name":"DevOps","slug":"DevOps","permalink":"https://blog.shichanson.site/categories/DevOps/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://blog.shichanson.site/tags/tools/"}],"author":"Mayer Shi"},{"title":"docker 搭建 shadowsocks 服务器","slug":"docker-shadowsocks-install","date":"2019-11-20T03:58:10.000Z","updated":"2019-11-20T03:58:10.000Z","comments":true,"path":"2019/11/20/docker-shadowsocks-install/","link":"","permalink":"https://blog.shichanson.site/2019/11/20/docker-shadowsocks-install/","excerpt":"搭建科学上网工具，想必通过Docker 部署的方式是最高效和简单的。本篇文章则是介绍如何通过docker 搭建 shadowsock 科学上网服务。","text":"搭建科学上网工具，想必通过Docker 部署的方式是最高效和简单的。本篇文章则是介绍如何通过docker 搭建 shadowsock 科学上网服务。 安装docker命令行工具 12345678910111213sudo apt-get remove docker docker-engine docker.iosudo apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-commoncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -sudo add-apt-repository \\ &quot;deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot;sudo apt-get updatesudo apt-get install docker-ce 执行如下命令，同时执行开放相应的防火墙 1docker run -d --restart unless-stopped -p 12345:12345 oddrationale/docker-shadowsocks -s 0.0.0.0 -p 12345 -k test12345 -m aes-256-cfb","categories":[{"name":"Ops","slug":"Ops","permalink":"https://blog.shichanson.site/categories/Ops/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://blog.shichanson.site/tags/tools/"}],"author":"Mayer Shi"},{"title":"gitlab 服务器参数优化","slug":"gitlab-ops","date":"2019-05-18T19:09:58.000Z","updated":"2019-05-18T19:09:58.000Z","comments":true,"path":"2019/05/19/gitlab-ops/","link":"","permalink":"https://blog.shichanson.site/2019/05/19/gitlab-ops/","excerpt":"很多企业在生产实践中采用 spring cloud 框架做开发以及 k8s 做部署的方案，但是在实践中也遇到测试环境容器的私有 IP 无法被调用本地应用调用的问题。","text":"很多企业在生产实践中采用 spring cloud 框架做开发以及 k8s 做部署的方案，但是在实践中也遇到测试环境容器的私有 IP 无法被调用本地应用调用的问题。 问题背景 我们公司的研发分为天津和北京两个开发团队共同开发一个整体应用，负责不同功能组件的开发。同时开发环境也是部署在 k8s 上的，所以服务暴露给开发调用的方式并不是很多。比如： 采用 loadbalancer，ingress 等方案，但是这种不够灵活，同时也无法解决服务注册和发现的问题。 出现问题 生产环境某个应用系统部分服务组件容器出现的不断重启现象。 gitlab web 服务正常，但是 git shell 推送时常卡慢甚至无法推送代码。 jenkins 测试环境也是大面积的构建任务失败。 gitlab 容器内存占用居高不下。 故障原因 生产环境出问题的应用系统进过排查后，得出的原因在于应用采用的是 spring cloud 框架，而应用的配置下发拉取采用的是 spring cloud 框架的 config server 组件。应用最终的配置文件是存储在 gitlab 中。由于应用在配置的时候没有关闭应用运行后继续拉取配置的选项。应用定期会自动从 config server 拉取配置，但是 config server 从 gitlab 的 repo 同步配置的时候失败了，运行的应用也就无法拉取到相应的配置，最终导致应用无法正常启动应用且 pod 不断重启的原因。 题外话： 用 gitlab 做 config server 配置文件的管理的管理在社区还是饱受争议的。另外我们也在调研通过 k8s configmap 作为配置文件管理的方案。 我们的日常测试环境的构建频率相当频发，所以拉取代码也会很频繁，但是构建任务大规模失败的原因在于，每次发布新版本的时候，我们会通过 helm 进行版本管理，charts 的变更会被推送到 gitlab 中。基本上是推送 charts 变更的时候出的问题。 代码无法推送等以上各种现象其实本质上都是 gitlab 出了问题。同时我们也发现 gitlab 容器消耗内存也是特别的高。 调优方式 按照官方文档说明上的介绍，当前 gitlab 能承载的能力最起码也得有一两千人的规模，事实是一百多人的规模就出现 gitlab 各种卡顿的问题。因此我们对 gitlab 的配置参数进行优化。 1.增加进程数和超时时间 1234# 超时时间默认值60sunicorn[&#x27;worker_timeout&#x27;] = 60# 不能低于2，否则卡死，官方推荐 worker=CPU核数+1，CPU是4C。unicorn[&#x27;worker_processes&#x27;] = 5 2.GitLab 默认使用了 PostgreSQL，优化 PostgreSQL 12345678# 减少数据库缓存大小 默认256，可适当改小postgresql[&#x27;shared_buffers&#x27;] = &quot;256MB&quot;# 减少数据库并发数postgresql[&#x27;max_worker_processes&#x27;] = 8# 减少sidekiq并发数sidekiq[&#x27;concurrency&#x27;] = 10 3.减少 unicorn 内存使用 123# 减少内存unicorn[&#x27;worker_memory_limit_min&#x27;] = &quot;200 * 1 &lt;&lt; 20&quot;unicorn[&#x27;worker_memory_limit_max&#x27;] = &quot;300 * 1 &lt;&lt; 20&quot; 4.重新加载配置以及重启服务生效配置 12345# 重新加载配置gitlab-ctl reconfigure# 重启所有组件生效配置gitlab-ctl restart 总结： 经过以上的参数配置的调优以及重启生效后，的确解决了生产环境以及 gitlab 的各种问题。","categories":[{"name":"Ops","slug":"Ops","permalink":"https://blog.shichanson.site/categories/Ops/"}],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"https://blog.shichanson.site/tags/gitlab/"}],"author":"Mayer Shi"},{"title":"算法解析-二分查找","slug":"coding-py","date":"2019-05-05T00:07:07.000Z","updated":"2019-05-05T00:07:07.000Z","comments":true,"path":"2019/05/05/coding-py/","link":"","permalink":"https://blog.shichanson.site/2019/05/05/coding-py/","excerpt":"常用算法学习，并附上 python 代码实现。该篇博客主要介绍二分查找算法的原理解析与代码实现。","text":"常用算法学习，并附上 python 代码实现。该篇博客主要介绍二分查找算法的原理解析与代码实现。 场景解析： 现在假设你登录 Facebook。当你这样做时，Facebook 必须核实你是否有其网站的账户，因此必须在其数据库中查找你的用户名。如果你的用户名为 karlmageddon，Facebook 可从以 A 打头的部分开始查找，但更合乎逻辑的做法是从中间开始查找。这是一个查找问题，在前述所有情况下，都可使用同一种算法来解决问题，这种算法就是二分查找 。 基本条件： 二分查找是一种算法，其输入是一个有序的元素列表。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回 null 。 算法原理解析： 从 1-100 中随机挑出一个数字，然后用最少的次数猜中这个次数，如果用蛮力的方法从 1 开始猜，如果挑中的数字是 99 那么最起码要猜 99 次。那么介绍另外一种方法，从 50 开始猜。小了，但排除了一半的数字！至此，你知道 1 ～ 50 都小了。接下来，你猜 75。大了，那余下的数字又排除了一半！使用二分查找时，你猜测的是中间的数字，从而每次都将余下的数字排除一半。接下来，你猜 63（50 和 75 中间的数字）。经过几次猜测即可猜中。这就是二分查找原理。那么对于二分查找一般多少次可以能猜中呢。 答案：log2N 次 公式解析：对数 你可能不记得什么是对数了，但很可能记得什么是幂。log10 100 相当于问“将多少个 10 相乘的结果为 100”。答案是两个：10 × 10 = 100。因此，log10 100 = 2。对数运算是幂运算的逆运算。 code 片段演示： 1234567891011121314151617181920212223# -*- coding: utf-8 -*-&quot;&quot;&quot;二分查找代码实现&quot;&quot;&quot;def fastSearch(glist, guess): start = 0 end = len(glist) - 1 while start &lt;= end: mid = (end + start) // 2 if guess == glist[mid]: return mid elif guess &gt; glist[mid]: start = mid + 1 else: end = mid - 1 return Noneif __name__ == &quot;__main__&quot;: ls = [1, 2, 3, 4, 5, 6, 7, 8] guess = 3 print(fastSearch(ls, guess)) 注意事项： 数组一定是有序的。 运行时间: 一般而言，应选择效率最高的算法，以最大限度地减少运行时间或占用空间。对于 40 亿有序数组的普通查找最多用 40 亿次方可查询到，对于查询时间与数组长度成正比，称为线性时间。而对于通过二分法查找的方式，40 亿数组则需要最多需要 40 亿的对数次。二分查找的运行时间为对数时间。 大 O 表示法: 大 O 表示法是一种特殊方法，他表示方法的速度有多快。表示方法是 O(log2N).其中 log2N 表示操作数。 适用场景: 大 O 表示法所能代表的是当前算法最糟糕的时候运行时间。 常见运行时间: O(logn)，也叫对数时间，这样的算法包括二分查找。 O(n)，也叫线性时间，这样的算法包括简单查找。 O(n*logn)，这样的算法包括第 4 章将介绍的快速排序——一种速度较快的排序算法。 O(n2)，这样的算法包括第 2 章将介绍的选择排序——一种速度较慢的排序算法。 O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。 运行时间总结: 算法的速度指的并非时间，而是操作数的增速。 谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。 算法的运行时间用大 O 表示法表示。O(log n)比 O(n)快，当需要搜索的元素越多时，前者比后者快得越多。","categories":[{"name":"Coding","slug":"Coding","permalink":"https://blog.shichanson.site/categories/Coding/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.shichanson.site/tags/%E7%AE%97%E6%B3%95/"}],"author":"Mayer Shi"},{"title":"helm使用技巧篇","slug":"magic-of-helm","date":"2019-01-03T04:23:50.000Z","updated":"2019-01-03T04:23:50.000Z","comments":true,"path":"2019/01/03/magic-of-helm/","link":"","permalink":"https://blog.shichanson.site/2019/01/03/magic-of-helm/","excerpt":"helm 的核心优点在于 charts 一次编写到处运行以及其版本跟踪的能力。本篇博文主要讲述 helm 在本地开发 charts 时的一些技巧，通过这些技巧可以大大增加 charts 的易用性以及扩展性。","text":"helm 的核心优点在于 charts 一次编写到处运行以及其版本跟踪的能力。本篇博文主要讲述 helm 在本地开发 charts 时的一些技巧，通过这些技巧可以大大增加 charts 的易用性以及扩展性。 针对 helm 篇的实践落地方案分为如下几个部分： helm 基础理论篇 helm 使用技巧篇 基础中间件服务运维篇 微服务应用版本管理篇 基于 jenkins + helm 的 CICD 方案 Helm 实践趟坑篇 基于 Helm Istio Jenkins 灰度发布实践方案 本篇博文是该系列博客中的第二篇文章**《helm 的使用技巧》**。社区以及官方文档大多提供的是针对单个服务的 charts 编写指导。对于有依赖关系的多个服务时也是通过子 charts 的方式来实现多服务组件部署，但是本质上还是一个 charts 一个服务。这对于动辄十来个组件的微服务架构应用来说，显然是不可取的方案。针对微服务应用场景，我们总结一些 helm 撰写 charts 的最佳实践。 debug 调试妙用 使用场景： helm 应用发布工具一般很少单独使用，在企业中的应用一般都是作为 DevOps 工具链中的一环。我们在做基础服务运维的时候一般都应该遵循一个基本原则“infra as code”。这样可以确保基础服务的可控和可追溯性。为了避免 charts 在实际运行中出错，我们可以在本地写 charts 的时候通过 debug 的功能，在不生成具体 release 的情况下检查 charts 是否存在语法错误和内容错误。 实践总结： 使用 Debug 功能的前提需要一个 k8s 集群且本地 helm 能够连接上该集群。最佳实践是尽可能确保本地 k8s 环境能与测试以及生产环境保持一致，这样才能确保 charts 的兼容性。笔者就遇到过这样的问题，charts 中包含了阿里云的日志服务 yaml 模板，在本地 minikube 集群上使用 helm 工具 debug 的时候总是报错的情况。最后将本地的 helm 工具直接连接阿里云上的 k8s 集群上，才顺利 debug。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140helm install --dry-run --debug --name test tomcat[debug] Created tunnel using local port: &#x27;51358&#x27;[debug] SERVER: &quot;127.0.0.1:51358&quot;[debug] Original chart version: &quot;&quot;[debug] CHART PATH: /Users/mayershi/akd/charts/stable/tomcatNAME: testREVISION: 1RELEASED: Sat Mar 16 12:49:23 2019CHART: tomcat-0.2.0USER-SUPPLIED VALUES:&#123;&#125;COMPUTED VALUES:affinity: &#123;&#125;deploy: directory: /usr/local/tomcat/webappsimage: pullPolicy: IfNotPresent pullSecrets: [] tomcat: repository: tomcat tag: &quot;7.0&quot; webarchive: repository: ananwaresystems/webarchive tag: &quot;1.0&quot;ingress: annotations: &#123;&#125; enabled: false hosts: - chart-example.local path: / tls: []livenessProbe: initialDelaySeconds: 60 path: /sample periodSeconds: 30nodeSelector: &#123;&#125;readinessProbe: failureThreshold: 6 initialDelaySeconds: 60 path: /sample periodSeconds: 30replicaCount: 1resources: &#123;&#125;service: externalPort: 80 internalPort: 8080 name: http type: LoadBalancertolerations: []HOOKS:MANIFEST:---# Source: tomcat/templates/appsrv-svc.yamlapiVersion: v1kind: Servicemetadata: name: test-tomcat labels: app: tomcat chart: tomcat-0.2.0 release: test heritage: Tillerspec: type: LoadBalancer ports: - port: 80 targetPort: 8080 protocol: TCP name: http selector: app: tomcat release: test---# Source: tomcat/templates/appsrv.yamlapiVersion: apps/v1beta2kind: Deploymentmetadata: name: test-tomcat labels: app: tomcat chart: tomcat-0.2.0 release: test heritage: Tillerspec: replicas: 1 selector: matchLabels: app: tomcat release: test template: metadata: labels: app: tomcat release: test spec: volumes: - name: app-volume emptyDir: &#123;&#125; initContainers: - name: war image: ananwaresystems/webarchive:1.0 imagePullPolicy: IfNotPresent command: - &quot;sh&quot; - &quot;-c&quot; - &quot;cp /*.war /app&quot; volumeMounts: - name: app-volume mountPath: /app containers: - name: tomcat image: tomcat:7.0 imagePullPolicy: IfNotPresent volumeMounts: - name: app-volume mountPath: /usr/local/tomcat/webapps ports: - containerPort: 8080 hostPort: 8009 livenessProbe: httpGet: path: /sample port: 8080 initialDelaySeconds: 60 periodSeconds: 30 readinessProbe: httpGet: path: /sample port: 8080 initialDelaySeconds: 60 periodSeconds: 30 failureThreshold: 6 resources: &#123;&#125; 多组件利器数组 在社区以及一些其他同行的博客教程中一般都是单个服务单个 charts 的方式，但是这种对于采用了微服务架构的应用是有问题的。有很多的缺陷，比如： 不能对应用进行统一的版本管理；需要编写大量的 charts 效率不高。那么解决这个问就需要引入 helm 的控制结构。 helm 循环控制结构： values.yaml 值文件部分示例内容。 12345678910111213141516171819202122232425262728293031323334353637383940414243containers: - name: app1 replicaCount: 2 image: name: app1:1 repository: dockerhub.com pullPolicy: Always service: type: ClusterIP externalPort: 8080 internalPort: 8080 healthUrl: /token managementPort: 8080 container: spring: false limitmemory: 256Mi env: &#123;&#125; - name: app2 replicaCount: 2 image: name: app2:1 repository: dockerhub.com pullPolicy: Always service: type: ClusterIP externalPort: 12180 internalPort: 12180 healthUrl: &quot;/manage/status&quot; managementPort: 12181 container: memory: 2048Mi limitmemory: 2048Mi spring: true hpa: type: memory value: 80 env: - name: ALI_LOGSTORE value: app2 deploy 和 service 模板文件内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&#123;&#123;- range $index, $container := .Values.containers &#125;&#125; // 由于helm是golang开发的所以，对于控制结构来说，他的循环控制结构和golang保持一致。通过这个循环控制结构可以将value值文件中的containers值下面的数组给遍历出来生成相应的deploy 和 service 的k8s的资源。---apiVersion: apps/v1beta2kind: Deploymentmetadata: name: &#123;&#123; $fullname &#125;&#125;-&#123;&#123; $container.name &#125;&#125; labels: app: &#123;&#123; $fullname &#125;&#125;-&#123;&#123; $container.name &#125;&#125; chart: &#123;&#123; $chartname &#125;&#125; release: &#123;&#123; $root.Release.Name &#125;&#125; heritage: &#123;&#123; $root.Release.Service &#125;&#125;spec: replicas: &#123;&#123; $container.replicaCount &#125;&#125; selector: matchLabels: app: &quot;&#123;&#123; $fullname &#125;&#125;-&#123;&#123; $container.name &#125;&#125;&quot; release: &quot;&#123;&#123; $root.Release.Name &#125;&#125;&quot; template: metadata: labels: app: &quot;&#123;&#123; $fullname &#125;&#125;-&#123;&#123; $container.name &#125;&#125;&quot; release: &quot;&#123;&#123; $root.Release.Name &#125;&#125;&quot; spec: imagePullSecrets: - name: aliyun-registry-secret containers: - name: &#123;&#123; $fullname &#125;&#125;-&#123;&#123; $container.name &#125;&#125; image: &#123;&#123; $container.image.repository &#125;&#125;/&#123;&#123; $container.image.name &#125;&#125; imagePullPolicy: &#123;&#123; $container.image.pullPolicy &#125;&#125; ports: - containerPort: &#123;&#123; $container.service.internalPort &#125;&#125; &#123;&#123; if $container.service.healthUrl &#125;&#125; livenessProbe: httpGet: path: &#123;&#123; $container.service.healthUrl &#125;&#125; port: &#123;&#123; $container.service.managementPort &#125;&#125; initialDelaySeconds: 60 timeoutSeconds: 10 periodSeconds: 30 successThreshold: 1 failureThreshold: 5 readinessProbe: httpGet: path: &#123;&#123; $container.service.healthUrl &#125;&#125; port: &#123;&#123; $container.service.managementPort &#125;&#125; initialDelaySeconds: 60 timeoutSeconds: 10 periodSeconds: 30 successThreshold: 1 failureThreshold: 5 &#123;&#123; end &#125;&#125; env: - name: aliyun_logs_image_tags value: docker-image=&#123;&#123; $container.image.repository &#125;&#125;/&#123;&#123; $container.image.name &#125;&#125; &#123;&#123; if $container.container.spring &#125;&#125; - name: JAVA_OPTIONS value: &gt;- -XX:+UseG1GC -XX:+HeapDumpOnOutOfMemoryError -Duser.timezone=Asia/Hong_Kong -Dspring.profiles.active=&#123;&#123; $root.Values.container.spring.profile &#125;&#125; &#123;&#123; end &#125;&#125;&#123;&#123; if $container.container.env &#125;&#125;&#123;&#123; toYaml $container.container.env | indent 10 &#125;&#125;&#123;&#123; end &#125;&#125; resources: &#123;&#123; if or $container.container.cpu $container.container.memory &#125;&#125; requests: &#123;&#123; if $container.container.cpu &#125;&#125; cpu: &quot;&#123;&#123; $container.container.cpu &#125;&#125;&quot; &#123;&#123; end &#125;&#125; &#123;&#123; if $container.container.memory &#125;&#125; memory: &quot;&#123;&#123; $container.container.memory &#125;&#125;&quot; &#123;&#123; end &#125;&#125; &#123;&#123; end &#125;&#125; &#123;&#123; if or $container.container.limitcpu $container.container.limitmemory &#125;&#125; limits: &#123;&#123; if $container.container.limitcpu &#125;&#125; cpu: &quot;&#123;&#123; $container.container.limitcpu &#125;&#125;&quot; &#123;&#123; end &#125;&#125; &#123;&#123; if $container.container.limitmemory &#125;&#125; memory: &quot;&#123;&#123; $container.container.limitmemory &#125;&#125;&quot; &#123;&#123; end &#125;&#125; &#123;&#123; end &#125;&#125;---apiVersion: v1kind: Servicemetadata: name: &#123;&#123; $serviceprefix &#125;&#125;-&#123;&#123; $container.name &#125;&#125; labels: app: &#123;&#123; $name &#125;&#125; chart: &#123;&#123; $chartname &#125;&#125; release: &#123;&#123; $root.Release.Name &#125;&#125; heritage: &#123;&#123; $root.Release.Service &#125;&#125;spec: type: &#123;&#123; $container.service.type &#125;&#125; ports: - port: &#123;&#123; $container.service.externalPort &#125;&#125; targetPort: &#123;&#123; $container.service.internalPort &#125;&#125; protocol: TCP name: &#123;&#123; $fullname &#125;&#125;-&#123;&#123; $container.name &#125;&#125;-http selector: app: &#123;&#123; $fullname &#125;&#125;-&#123;&#123; $container.name &#125;&#125; release: &#123;&#123; $root.Release.Name &#125;&#125;&#123;&#123;- end &#125;&#125; 将 values.yaml 值文件 和 deploy-server.yaml 模板文件通过 helm 渲染得出真正的 deploy 的 yaml 以及 service 的 yaml 文件。然后 k8s 接受到后，会生成相应的资源。 组件个性化开关 每个应用的配置以及运行状态是不一样的,比如: java 启动的参数，node 应用的启动环境变量等等，所以就涉及到应用个性化参数开关的问题，那么解决这个的方案就是 helm 的条件控制结构。 helm 条件控制结构 上面的实例文件中 containers 的数组的每个想内部存的是单个 deploy + service 的 value 值。从文件中可以看出差异部分。 第一个服务组件的值文件 spring 的值是 false。 123456789101112131415```第二个服务组件的值文件 spring 的值是 true。```yamlcontainer: memory: 2048Mi limitmemory: 2048Mi spring: true hpa: type: memory value: 80 env: - name: ALI_LOGSTORE value: app2 deploy-service.yaml 文件中关于这块的文件描述是这样的。 1234567891011env: - name: aliyun_logs_image_tags value: docker-image=&#123;&#123; $container.image.repository &#125;&#125;/&#123;&#123; $container.image.name &#125;&#125; &#123;&#123; if $container.container.spring &#125;&#125; - name: JAVA_OPTIONS value: &gt;- -XX:+UseG1GC -XX:+HeapDumpOnOutOfMemoryError -Duser.timezone=Asia/Hong_Kong -Dspring.profiles.active=&#123;&#123; $root.Values.container.spring.profile &#125;&#125; &#123;&#123; end &#125;&#125; 运行结果就是当 spring 值是 true 的时候。env 的内容就会添加 Java 启动的环境变量参数。spring 值为 false 的时候就不会添加该环境变量。","categories":[{"name":"Container Cloud","slug":"Container-Cloud","permalink":"https://blog.shichanson.site/categories/Container-Cloud/"}],"tags":[{"name":"helm","slug":"helm","permalink":"https://blog.shichanson.site/tags/helm/"}],"author":"Mayer Shi"},{"title":"helm基础概念","slug":"helm-basic","date":"2018-12-10T18:28:13.000Z","updated":"2018-12-10T18:28:13.000Z","comments":true,"path":"2018/12/11/helm-basic/","link":"","permalink":"https://blog.shichanson.site/2018/12/11/helm-basic/","excerpt":"Kubernetes的巨大成功创造了一个工具生态系统，可以简化应用程序开发和部署的复杂性。而该系列文章主要分享helm在噼里啪技术团队的生产实践经验总结。","text":"Kubernetes的巨大成功创造了一个工具生态系统，可以简化应用程序开发和部署的复杂性。而该系列文章主要分享helm在噼里啪技术团队的生产实践经验总结。 针对helm篇的实践落地方案分为如下几个部分： helm 基础理论篇 helm 使用技巧篇 基础中间件服务运维篇 微服务应用版本管理篇 基于jenkins + helm的CICD方案 Helm 实践趟坑篇 基于Helm Istio Jenkins灰度发布实践方案 helm 是什么 helm 是一款可以帮你在k8s上很好运维管理复杂的应用包管理工具。如果把k8s比作CentOS操作系统的话，那么helm类似CentOS系统中的yum工具。 这两个工具从某种程度来说的确很相似，yum可以解决rpm之间的依赖问题，而helm也可以解决应用与基础服务依赖关系。比如：WordPress应用启动之前需要启动MySQL，那就可以在WordPress的charts里定义需要依赖MySQL的charts。那么在部署WordPress的charts时，helm也会拉取并部署MySQL的Charts。 helm 名称概念 Charts: yum安装的rpm包则对应helm的charts。charts包含了整套复杂应用组件的k8s资源（Deployment、Service、Ingress、ConfigMap、Secret等）模板yaml文件以及模板对应value文件。Chart的目录结构如下： 12345678910mychart├── Chart.yaml├── charts├── templates│ ├── NOTES.txt│ ├── _helpers.tpl│ ├── deployment.yaml│ ├── ingress.yaml│ └── service.yaml└── values.yaml charts 目录存放依赖的 chart Chart.yaml 包含 Chart 的基本信息，包括 chart 版本，名称等 templates 目录下存放应用一系列 k8s 资源的 yaml 模板 _helpers.tpl 此文件中定义一些可重用的模板片断，此文件中的定义在任何资源定义模板中可用 NOTES.txt 介绍 chart 部署后的帮助信息，如何使用 chart 等 values.yaml 包含了必要的值定义（默认值）, 用于存储 templates 目录中模板文件中用到变量的值 Release: 扩展上述类比，要在基于CentOS的系统上安装NGNIX，您将运行yum install nginx。同样，要将NGINX安装到Kubernetes集群，您只需运行helm install nginx即可。每次向群集安装Charts都称为release。但是，与传统的操作系统软件包管理器不同，使用Helm可以轻松地将一个charts多次安装到单个集群中，每个release都有自己的特定配置。所以简单的来说一个release就是一个charts的实例化。 12helm ls istio 1 Thu Dec 13 11:50:08 2018 DEPLOYED ack-istio-1.0.4 1.0.4 istio-system Repositories: Helm Charts 还可以发布到存储库。这些charts可以发布到私有仓库，也可以是公共托管。像yum和apt一样，可以搜索它们以发现可用的charts。 123456helm search nginxNAME CHART VERSION APP VERSION DESCRIPTIONstable/nginx-ingress 1.0.0 0.21.0 An nginx Ingress controller that uses ConfigMap to store ...stable/nginx-ldapauth-proxy 0.1.2 1.13.5 nginx proxy with ldapauthstable/nginx-lego 0.3.1 Chart for nginx-ingress-controller and kube-legostable/gcloud-endpoints 0.1.2 1 DEPRECATED Develop, deploy, protect and monitor your APIs... HELM 核心组件 helm 是个客户端工具，它主要的作用如下： 本地chart开发 管理repositories 与tiller 服务端进行交互 发送要安装的charts 获取相关release的信息 请求更新或者删除已存在的release tiller 是一个部署在k8s集群内部的一个与helm客户端进行交互同时也与k8s api连接的服务。主要负责如下功能： 监听来自helm客户端传入的请求 将charts和配置组合渲染来构建一个release 将charts部署到k8s集群中并跟踪后续版本 通过与k8s进行交互来更新以及删除集群中存在的release。 ![](/media/posts/media/jh.png) 简而言之，helm 客户端负责管理charts, tiller 服务端负责管理release生命周期。 helm 内部实现 Helm客户端使用Go编程语言编写，并使用gRPC协议与Tiller服务器进行交互。 Tiller服务端也是用Go编写的。它提供了一个与客户端连接的gRPC服务器，它使用Kubernetes客户端库与Kubernetes进行通信。目前，该库使用REST + JSON。 Tiller服务器将信息存储在位于Kubernetes内的ConfigMaps中。它不需要自己的数据库。 release 管理机制 创建 release helm 客户端从指定的目录或本地 tar 文件或远程 repo 仓库解析出 chart 的结构信息 helm 客户端指定的 chart 结构和 values 信息通过 gRPC 传递给 Tiller Tiller 服务端根据 chart 和 values 生成一个 release Tiller 将 install release 请求直接传递给 kube-apiserver 更新 release helm 客户端将需要更新的 chart 的 release 名称 chart 结构和 value 信息传给 Tiller Tiller 将收到的信息生成新的 release，并同时更新这个 release 的 history Tiller 将新的 release 传递给 kube-apiserver 进行更新 删除 release helm 客户端从指定的目录或本地 tar 文件或远程 repo 仓库解析出 chart 的结构信息 helm 客户端指定的 chart 结构和 values 信息通过 gRPC 传递给 Tiller Tiller 服务端根据 chart 和 values 生成一个 release Tiller 将 delete release 请求直接传递给 kube-apiserver","categories":[{"name":"Container Cloud","slug":"Container-Cloud","permalink":"https://blog.shichanson.site/categories/Container-Cloud/"}],"tags":[{"name":"helm","slug":"helm","permalink":"https://blog.shichanson.site/tags/helm/"}],"author":"Mayer Shi"},{"title":"创世纪","slug":"创世纪","date":"2018-11-22T07:14:21.000Z","updated":"2018-11-22T07:14:21.000Z","comments":true,"path":"2018/11/22/创世纪/","link":"","permalink":"https://blog.shichanson.site/2018/11/22/%E5%88%9B%E4%B8%96%E7%BA%AA/","excerpt":"开博客啦！ 这是我的个人博客，将在这里分享我的成长路上学习心得和收获。","text":"开博客啦！ 这是我的个人博客，将在这里分享我的成长路上学习心得和收获。","categories":[{"name":"Story","slug":"Story","permalink":"https://blog.shichanson.site/categories/Story/"}],"tags":[{"name":"story","slug":"story","permalink":"https://blog.shichanson.site/tags/story/"}],"author":"Mayer Shi"}],"categories":[{"name":"Tools","slug":"Tools","permalink":"https://blog.shichanson.site/categories/Tools/"},{"name":"Ops","slug":"Ops","permalink":"https://blog.shichanson.site/categories/Ops/"},{"name":"frontend","slug":"frontend","permalink":"https://blog.shichanson.site/categories/frontend/"},{"name":"ROS","slug":"ROS","permalink":"https://blog.shichanson.site/categories/ROS/"},{"name":"GitOps","slug":"GitOps","permalink":"https://blog.shichanson.site/categories/GitOps/"},{"name":"DevOps","slug":"DevOps","permalink":"https://blog.shichanson.site/categories/DevOps/"},{"name":"Container Cloud","slug":"Container-Cloud","permalink":"https://blog.shichanson.site/categories/Container-Cloud/"},{"name":"Coding","slug":"Coding","permalink":"https://blog.shichanson.site/categories/Coding/"},{"name":"Story","slug":"Story","permalink":"https://blog.shichanson.site/categories/Story/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://blog.shichanson.site/tags/tools/"},{"name":"前端跨域","slug":"前端跨域","permalink":"https://blog.shichanson.site/tags/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F/"},{"name":"机器人","slug":"机器人","permalink":"https://blog.shichanson.site/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"},{"name":"zoom","slug":"zoom","permalink":"https://blog.shichanson.site/tags/zoom/"},{"name":"gitops","slug":"gitops","permalink":"https://blog.shichanson.site/tags/gitops/"},{"name":"gitlab","slug":"gitlab","permalink":"https://blog.shichanson.site/tags/gitlab/"},{"name":"kubernetes","slug":"kubernetes","permalink":"https://blog.shichanson.site/tags/kubernetes/"},{"name":"cmd","slug":"cmd","permalink":"https://blog.shichanson.site/tags/cmd/"},{"name":"算法","slug":"算法","permalink":"https://blog.shichanson.site/tags/%E7%AE%97%E6%B3%95/"},{"name":"helm","slug":"helm","permalink":"https://blog.shichanson.site/tags/helm/"},{"name":"story","slug":"story","permalink":"https://blog.shichanson.site/tags/story/"}]}